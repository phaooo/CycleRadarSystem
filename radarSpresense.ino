/**
 * @file radarSpresense.ino
 * @brief OLED display and radar control using U8g2 library and Arduino framework.
 * 
 * This program initializes an OLED display and a radar module, providing a user interface
 * to display radar information, configure settings, and show device information.
 * 
 * The main functionalities include:
 * - Displaying radar information with target detection.
 * - Providing a settings menu to configure radar parameters.
 * - Showing device information and firmware version.
 * - Handling button inputs for navigation and configuration.
 * 
 * The program uses the U8g2 library for OLED display control and communicates with the radar
 * module via UART. It includes various UI states and animations for a smooth user experience.
 * 
 * @note The radar module used is LD-2451, and the MCU is SPRESENSE.
 * 
 * @version 1.0
 * @date November 17, 2024
 * 
 * @section Constants
 * - SPEED: Animation speed divisor.
 * - ICON_SPEED: Icon animation speed.
 * - ICON_SPACE: Icon spacing.
 * - LED_PIN: LED output pin.
 * - BTN0, BTN1, BTN2, BTN3: Button pin definitions.
 * - bitmapA_width, bitmapA_height: Bitmap A dimensions.
 * - bitmapB_width, bitmapB_height: Bitmap B dimensions.
 * 
 * @section Variables
 * - SETTING_MIN: Minimum setting values.
 * - SETTING_MAX: Maximum setting values.
 * - Setdata: Current setting values.
 * - disappear_step: Step counter for screen transition effect.
 * - buf_ptr: Pointer to display buffer.
 * - buf_len: Length of display buffer.
 * - x, y, y_trg: Current and target Y positions for menu animations.
 * - line_y, line_y_trg: Line positions for menu animations.
 * - box_width, box_width_trg: Box dimensions for menu animations.
 * - box_y, box_y_trg: Box positions for menu animations.
 * - ui_select: Selected menu item index.
 * - set_y, set_y_trg: Current and target Y positions for settings menu.
 * - set_line_y, set_line_y_trg: Line positions for settings menu.
 * - set_box_width, set_box_width_trg: Box dimensions for settings menu.
 * - set_box_y, set_box_y_trg: Box positions for settings menu.
 * - set_select: Selected settings menu item index.
 * - sendProgress: Progress of sending configuration.
 * - sendStartTime: Start time of sending configuration.
 * - isSending: Flag indicating if configuration is being sent.
 * - icon_x, icon_x_trg: Current and target X positions for icon animations.
 * - app_y, app_y_trg: Current and target Y positions for app animations.
 * - icon_select: Selected icon index.
 * - ui_index, ui_state: Current UI state and index.
 * - firmwareVersion: Firmware version string.
 * - key: Button state array.
 * - key_msg: Button message structure.
 * 
 * @section Functions
 * - get_key_val: Get the state of a button.
 * - key_init: Initialize button states.
 * - key_scan: Scan for button presses.
 * - move: Animate movement of a value towards a target.
 * - move_icon: Animate movement of an icon towards a target.
 * - move_width: Animate width change of a box.
 * - move_bar: Animate progress bar.
 * - disappear: Screen transition effect.
 * - parseRadarData: Parse radar data and extract target information.
 * - getFirmwareVersion: Get firmware version string.
 * - sendEnableCommand: Send enable configuration command to radar.
 * - readAck: Read ACK response from radar.
 * - resetToFactory: Reset radar to factory settings.
 * - readFirmwareVersion: Read firmware version from radar.
 * - sendEndConfigCommand: Send end configuration command to radar.
 * - setTargetDetectionParams: Set target detection parameters.
 * - readTargetDetectionParams: Read target detection parameters.
 * - setSensitivityParams: Set radar sensitivity parameters.
 * - readSensitivityParams: Read radar sensitivity parameters.
 * - info_ui_show: Display info screen with version information.
 * - select_ui_show: Display selection menu interface.
 * - set_ui_show: Display settings interface.
 * - set_edit_ui_show: Display settings editor interface.
 * - radar_ui_show: Display radar interface with target information.
 * - about_ui_show: Display about screen with device information.
 * - info_proc: Process info screen events.
 * - set_edit_proc: Process set edit screen events.
 * - set_proc: Process set screen events.
 * - select_proc: Process selection menu interface.
 * - radar_proc: Process radar interface and handle target detection.
 * - handleLEDBlinking: Handle LED blinking logic.
 * - processRadarData: Process radar data and update display.
 * - handleKeyEvents: Handle key press events in radar interface.
 * - about_proc: Process about page interface.
 * - ui_proc: Process main UI state machine and handle different UI pages.
 * - setup: Setup function - Initialize hardware and system parameters.
 * - loop: Main loop function.
 */
#include <U8g2lib.h>

// Speed and display constants
#define SPEED 4        // Divisor of 16 
#define ICON_SPEED 12  // Icon animation speed
#define ICON_SPACE 48  // Icon spacing
#define LED_PIN 3      // LED output pin

// Button pin definitions  
#define BTN0 5
#define BTN1 6 
#define BTN2 7
#define BTN3 4

// Bitmap dimensions
#define bitmapA_width 128
#define bitmapA_height 64
const unsigned char bitmapA_bits[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xE0, 0xFF, 0xE7, 0xE0, 0xFC, 0xDF, 0x01, 0xFF, 0x03, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xE7, 0xE0, 0xFE, 0xDF, 0x81, 0xFF, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xE7, 0xE0, 
  0xFE, 0xDF, 0x81, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x70, 0x00, 0xE0, 0xE0, 0x0E, 0xC0, 0x81, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0xE0, 0xE0, 0x0E, 0xC0, 0x81, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0xE0, 0xE0, 
  0x0E, 0xC0, 0x81, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x70, 0x00, 0xE0, 0xFF, 0x0E, 0xC0, 0x81, 0xFF, 0x03, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0xE0, 0xFF, 0x0E, 0xC0, 0x81, 0xFF, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0xC0, 0x7F, 
  0x0E, 0xC0, 0x81, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x70, 0x00, 0x00, 0x0E, 0x0E, 0xC0, 0x81, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x0E, 0x0E, 0xC0, 0x81, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x0E, 
  0x0E, 0xC0, 0x81, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x70, 0x00, 0x00, 0x0E, 0x0E, 0xC0, 0x81, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x07, 0x0E, 0xFE, 0xDF, 0x9F, 0xFF, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0x07, 0x0E, 
  0xFC, 0x9F, 0x1F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x0F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x0F, 
  0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xC7, 0x7F, 0xFC, 0x9F, 0xFF, 0x01, 
  0x00, 0x00, 0x70, 0x00, 0xF0, 0x01, 0x00, 0x00, 0xF0, 0xFF, 0xE7, 0xFF, 
  0xFE, 0xDF, 0xFF, 0x01, 0x00, 0x00, 0x70, 0x00, 0xF8, 0x01, 0x00, 0x00, 
  0xF0, 0xFF, 0xE7, 0xFF, 0xFE, 0xDF, 0xFF, 0x01, 0x00, 0x00, 0x70, 0x00, 
  0xFC, 0x01, 0x00, 0x00, 0x70, 0x00, 0xE0, 0xE0, 0x0E, 0xC0, 0x01, 0x00, 
  0x00, 0x00, 0xF0, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x70, 0x00, 0xE0, 0xE0, 
  0x0E, 0xC0, 0x01, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0x00, 0x00, 0x00, 
  0x70, 0x00, 0xE0, 0xE0, 0x0E, 0xC0, 0x01, 0x00, 0x00, 0x00, 0xF8, 0xFF, 
  0xFF, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xE3, 0xFF, 0xFE, 0xDF, 0xFF, 0x01, 
  0x00, 0x00, 0xF8, 0x00, 0xFC, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xE7, 0xFF, 
  0xFE, 0xDF, 0xFF, 0x01, 0x00, 0x00, 0xFC, 0x00, 0xDC, 0x01, 0x00, 0x00, 
  0xE0, 0xFF, 0xE7, 0xFF, 0xFE, 0xDF, 0xFF, 0x01, 0x00, 0xF8, 0xFF, 0x01, 
  0xCC, 0xFF, 0x01, 0x00, 0x00, 0x00, 0xE7, 0xE0, 0x0E, 0xC0, 0x01, 0x00, 
  0x00, 0xF8, 0xDF, 0x03, 0x8E, 0xFF, 0x01, 0x00, 0x00, 0x00, 0xE7, 0xE0, 
  0x0E, 0xC0, 0x01, 0x00, 0x00, 0x1E, 0x3C, 0x03, 0xC6, 0x87, 0x03, 0x00, 
  0x00, 0x00, 0xE7, 0xE0, 0x0E, 0xC0, 0x01, 0x00, 0x00, 0x0F, 0x3E, 0x07, 
  0xE7, 0x07, 0x0F, 0x00, 0x00, 0x00, 0xE7, 0xE0, 0x0E, 0xC0, 0x01, 0x00, 
  0x80, 0x07, 0x7E, 0x0F, 0x77, 0x07, 0x1C, 0x00, 0xF0, 0xFF, 0xE7, 0xE0, 
  0x0E, 0xC0, 0xFF, 0x01, 0xC0, 0x03, 0xFF, 0x9E, 0x3B, 0x0E, 0x38, 0x00, 
  0xF0, 0xFF, 0xE3, 0xE0, 0x0E, 0x80, 0xFF, 0x01, 0xC0, 0x81, 0xE3, 0xDD, 
  0x1B, 0x1E, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xC0, 0x80, 0xC1, 0xFB, 0x1D, 0x1E, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x80, 0x01, 0xFB, 0x0D, 0x18, 0x60, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xC0, 0x01, 0xFB, 
  0x0F, 0x38, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x60, 0xE0, 0x01, 0xFB, 0xFF, 0x7F, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x60, 0xE0, 0x01, 0xFB, 0xFF, 0x7F, 0x60, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xC0, 0x00, 0x73, 
  0x0E, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x60, 0x00, 0x00, 0x03, 0x1C, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x03, 0x1C, 0x00, 0x70, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0xC0, 0x01, 
  0x18, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xC0, 0x01, 0xE0, 0x00, 0x78, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0xF0, 0x00, 0xF0, 0x00, 0x3C, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x7C, 0x00, 
  0xE0, 0x81, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xFF, 0x3F, 0x00, 0xC0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x00, 0x00, 0xFF, 0x01, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
};

#define bitmapB_width 128 
#define bitmapB_height 64 
const unsigned char bitmapB_bits[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x71, 0x22, 0x7A, 
  0x8E, 0xE7, 0xE1, 0x0B, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x20, 0x8A, 0x26, 0x0B, 0x92, 0x20, 0x61, 0x92, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x20, 0x8A, 0x24, 0x09, 0x92, 0x20, 0x62, 0x92, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x8A, 0x24, 0x09, 
  0x92, 0x20, 0x62, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x20, 0x8A, 0x74, 0x09, 0x92, 0x20, 0x62, 0x62, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x89, 0x54, 0x79, 0x9E, 0x27, 0xE2, 0x63, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x88, 0x54, 0x09, 
  0x92, 0x20, 0x62, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x20, 0x88, 0x54, 0x09, 0x92, 0x20, 0x62, 0x62, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x20, 0x88, 0xDC, 0x09, 0x92, 0x20, 0x62, 0x62, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x88, 0x88, 0x08, 
  0x92, 0x20, 0x61, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x20, 0x70, 0x88, 0x78, 0xB2, 0xE7, 0xE1, 0x63, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x03, 0x7F, 0xC0, 0x7F, 0xE0, 
  0x07, 0xFF, 0x00, 0xC0, 0x81, 0x1F, 0xFE, 0x03, 0xC0, 0x7F, 0xFC, 0x0F, 
  0xFF, 0xC1, 0x7F, 0xF8, 0x8F, 0xFF, 0x71, 0xC0, 0xE1, 0x3F, 0xFE, 0x03, 
  0xE0, 0x78, 0xFC, 0x1F, 0xFF, 0xC3, 0x7F, 0x18, 0x8E, 0xFF, 0xF1, 0xC0, 
  0x71, 0x38, 0xFE, 0x03, 0x60, 0x00, 0x0C, 0x1C, 0x81, 0xC3, 0x00, 0x0C, 
  0x80, 0x01, 0xF0, 0xC1, 0x31, 0x00, 0x06, 0x00, 0x60, 0x00, 0x0C, 0x1C, 
  0x81, 0xC3, 0x00, 0x0C, 0x80, 0x01, 0xF0, 0xC1, 0x30, 0x00, 0x06, 0x00, 
  0x60, 0x00, 0x0C, 0x1C, 0x81, 0xC3, 0x00, 0x0C, 0x80, 0x01, 0xF0, 0xC3, 
  0x30, 0x00, 0x06, 0x00, 0x60, 0x03, 0x0C, 0x1C, 0x81, 0xC3, 0x00, 0xC8, 
  0x80, 0x01, 0xB0, 0xC3, 0x70, 0x01, 0x06, 0x00, 0xC0, 0x07, 0xFC, 0x1F, 
  0xFF, 0xC3, 0x3E, 0xF8, 0x81, 0xF9, 0x30, 0xC7, 0xE0, 0x07, 0xF6, 0x01, 
  0x80, 0x0F, 0xFC, 0x0F, 0xFF, 0xC1, 0x3E, 0xF0, 0x81, 0xF9, 0x30, 0xCF, 
  0xC0, 0x07, 0xF6, 0x01, 0x80, 0x1F, 0xFC, 0x03, 0x7F, 0xC0, 0x3E, 0xE0, 
  0x87, 0xF9, 0x30, 0xCE, 0x80, 0x0F, 0xF6, 0x01, 0x00, 0x3B, 0x0C, 0x00, 
  0x01, 0xC0, 0x00, 0xC0, 0x8F, 0x01, 0x30, 0xDC, 0x00, 0x1D, 0x06, 0x00, 
  0x00, 0x30, 0x0C, 0x00, 0xE1, 0xC0, 0x00, 0x00, 0x8C, 0x01, 0x30, 0xFC, 
  0x00, 0x38, 0x06, 0x00, 0x00, 0x70, 0x0C, 0x00, 0xE1, 0xC0, 0x00, 0x00, 
  0x8C, 0x01, 0x30, 0xF8, 0x00, 0x30, 0x06, 0x00, 0x00, 0x70, 0x0C, 0x00, 
  0xC1, 0xC1, 0x00, 0x00, 0x8C, 0x01, 0x30, 0xF8, 0x00, 0x30, 0x06, 0x00, 
  0x70, 0x30, 0x1C, 0x80, 0xC3, 0xC1, 0x00, 0x1C, 0x8E, 0x01, 0x30, 0xF0, 
  0x38, 0x18, 0x06, 0x00, 0xF0, 0x3F, 0x1C, 0x80, 0x83, 0xC3, 0x7F, 0xFC, 
  0x87, 0xFF, 0x79, 0xE0, 0xF8, 0x1F, 0xFE, 0x03, 0xF0, 0x1F, 0x1C, 0x80, 
  0x83, 0xC3, 0x7F, 0xFC, 0x83, 0xFF, 0x79, 0xE0, 0xF8, 0x0F, 0xFE, 0x03, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00,
};

// Radar background bitmap
const unsigned char radar_background[] PROGMEM = {
  0x00, 0x06, 0x18, 0x60, 0x80, 0x01, 0x06, 0x00, 0x00, 0x60, 0x80, 0x01, 
  0x06, 0x18, 0x60, 0x00, 0x00, 0x06, 0x18, 0x60, 0x80, 0x01, 0x06, 0x00, 
  0x00, 0x60, 0x80, 0x01, 0x06, 0x18, 0x60, 0x00, 0x00, 0x06, 0x18, 0x60, 
  0x80, 0x01, 0x06, 0x00, 0x00, 0x30, 0x80, 0x01, 0x06, 0x18, 0x60, 0x00, 
  0x00, 0x06, 0x18, 0x60, 0x80, 0x01, 0x0C, 0x00, 0x00, 0x30, 0x80, 0x01, 
  0x06, 0x18, 0x60, 0x00, 0x00, 0x06, 0x18, 0x60, 0x80, 0x01, 0x0C, 0x00, 
  0x00, 0x30, 0x80, 0x01, 0x06, 0x18, 0x60, 0x00, 0x00, 0x06, 0x18, 0x60, 
  0x00, 0x03, 0x18, 0x00, 0x00, 0x18, 0xC0, 0x00, 0x02, 0x18, 0x60, 0x00, 
  0x00, 0x06, 0x30, 0xC0, 0x00, 0x03, 0x18, 0x00, 0x00, 0x18, 0xC0, 0x00, 
  0x03, 0x0C, 0x60, 0x00, 0x00, 0x0C, 0x30, 0xC0, 0x00, 0x03, 0x30, 0x00, 
  0x00, 0x0C, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0x00, 0x00, 0x0C, 0x30, 0xC0, 
  0x00, 0x06, 0x60, 0x00, 0x00, 0x06, 0x60, 0x00, 0x03, 0x0C, 0x30, 0x00, 
  0x00, 0x0C, 0x30, 0xC0, 0x00, 0x06, 0xC0, 0x00, 0x00, 0x03, 0x60, 0x00, 
  0x03, 0x0C, 0x30, 0x00, 0x00, 0x0C, 0x30, 0x80, 0x01, 0x06, 0x80, 0x03, 
  0xC0, 0x01, 0x60, 0x80, 0x01, 0x0C, 0x30, 0x00, 0x00, 0x0C, 0x60, 0x80, 
  0x01, 0x0C, 0x00, 0x0F, 0xF8, 0x00, 0x30, 0x80, 0x01, 0x06, 0x30, 0x00, 
  0x00, 0x18, 0x60, 0x80, 0x01, 0x18, 0x00, 0xFC, 0x3F, 0x00, 0x18, 0x80, 
  0x01, 0x06, 0x18, 0x00, 0x00, 0x18, 0x60, 0x00, 0x03, 0x18, 0x00, 0xE0, 
  0x07, 0x00, 0x18, 0xC0, 0x00, 0x06, 0x18, 0x00, 0x00, 0x18, 0x60, 0x00, 
  0x03, 0x30, 0x00, 0x00, 0x00, 0x00, 0x0C, 0xC0, 0x00, 0x02, 0x18, 0x00, 
  0x00, 0x18, 0xC0, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 
  0x00, 0x03, 0x18, 0x00, 0x00, 0x30, 0xC0, 0x00, 0x06, 0xC0, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0x60, 0x00, 0x03, 0x0C, 0x00, 0x00, 0x30, 0x80, 0x01, 
  0x0C, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x30, 0x80, 0x01, 0x0C, 0x00, 
  0x00, 0x30, 0x80, 0x01, 0x0C, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x10, 
  0x80, 0x01, 0x0C, 0x00, 0x00, 0x60, 0x00, 0x03, 0x18, 0x00, 0x0E, 0x00, 
  0x00, 0x70, 0x00, 0x18, 0xC0, 0x00, 0x06, 0x00, 0x00, 0x60, 0x00, 0x03, 
  0x30, 0x00, 0x1C, 0x00, 0x00, 0x38, 0x00, 0x0C, 0xC0, 0x00, 0x06, 0x00, 
  0x00, 0x60, 0x00, 0x06, 0x60, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x06, 
  0x60, 0x00, 0x06, 0x00, 0x00, 0xC0, 0x00, 0x06, 0xC0, 0x00, 0xE0, 0x07, 
  0xE0, 0x07, 0x00, 0x03, 0x60, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x0C, 
  0xC0, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x03, 0x30, 0x00, 0x03, 0x00, 
  0x00, 0x80, 0x01, 0x0C, 0x80, 0x03, 0x00, 0xF8, 0x1F, 0x00, 0xC0, 0x01, 
  0x30, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x18, 0x00, 0x07, 0x00, 0x00, 
  0x00, 0x00, 0xE0, 0x00, 0x18, 0x80, 0x01, 0x00, 0x00, 0x00, 0x03, 0x30, 
  0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x0C, 0xC0, 0x00, 0x00, 
  0x00, 0x00, 0x06, 0x60, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 
  0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x70, 0x00, 0x00, 
  0x00, 0x00, 0x0E, 0x00, 0x03, 0x60, 0x00, 0x00, 0x00, 0x00, 0x0C, 0xC0, 
  0x00, 0xE0, 0x01, 0x00, 0x00, 0x80, 0x03, 0x00, 0x03, 0x30, 0x00, 0x00, 
  0x00, 0x00, 0x0C, 0x80, 0x01, 0x80, 0x07, 0x00, 0x00, 0xE0, 0x01, 0x80, 
  0x01, 0x30, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x03, 0x00, 0x3E, 0x00, 
  0x00, 0x7C, 0x00, 0xC0, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 
  0x06, 0x00, 0xF8, 0x03, 0xC0, 0x1F, 0x00, 0x70, 0x00, 0x0C, 0x00, 0x00, 
  0x00, 0x00, 0x60, 0x00, 0x1C, 0x00, 0xC0, 0xFF, 0xFF, 0x03, 0x00, 0x38, 
  0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x38, 0x00, 0x00, 0xFC, 
  0x1F, 0x00, 0x00, 0x0C, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 
  0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x03, 0x00, 0x00, 
  0x00, 0x00, 0x80, 0x01, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x07, 0x00, 0x00, 
  0x00, 0x00, 0xE0, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
  0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x60, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0C, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 
  0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0xE0, 0x01, 0x00, 
  0x00, 0x80, 0x07, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 
  0x00, 0x80, 0x1F, 0x00, 0x00, 0xF8, 0x01, 0x00, 0x0E, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xFC, 0x03, 0xC0, 0x3F, 0x00, 0x00, 
  0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0xE0, 0xFF, 
  0xFF, 0x07, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x07, 0x00, 0x00, 0xFC, 0x3F, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 
  0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x0F, 0x00, 0x00, 0xF0, 0x07, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x01, 
  0x80, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xF0, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x7F, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
};

// Display driver initialization
U8G2_SSD1309_128X64_NONAME0_F_4W_HW_SPI u8g2(U8G2_R0, 10, 9, 8);

// Setting limits
const float SETTING_MIN[4] = {10, 1, 0, 3};  
const float SETTING_MAX[4] = {100, 60, 10, 8};
float Setdata[4] = {20, 1, 2, 4};  // Setting values

// Animation variables
uint8_t disappear_step = 1;
uint8_t* buf_ptr;      // Buffer pointer
uint16_t buf_len;      // Buffer length

// Selection menu variables
uint8_t x;
int16_t y, y_trg;     // Current and target Y position
uint8_t line_y, line_y_trg;       // Line positions
uint8_t box_width, box_width_trg;  // Box dimensions
int16_t box_y, box_y_trg;         // Box positions
int8_t ui_select;                  // Selected menu item

// Settings menu variables
int16_t set_y, set_y_trg;
uint8_t set_line_y, set_line_y_trg;
uint8_t set_box_width, set_box_width_trg;
int16_t set_box_y, set_box_y_trg;
int8_t set_select;
uint8_t sendProgress = 0;
unsigned long sendStartTime = 0;
bool isSending = false;

// Icon menu variables
int16_t icon_x, icon_x_trg;
int16_t app_y, app_y_trg;
int8_t icon_select;

// UI state variables
uint8_t ui_index, ui_state;

// UI menu states
enum {
  M_INFO,           // Info screen
  M_SELECT,         // Selection menu
  M_SET,           // Settings menu
  M_SET_EDIT,      // Settings editor
  M_RADAR_DISPLAY, // Radar display
  M_ABOUT          // About screen
};

// UI animation states
enum {
  S_NONE,
  S_DISAPPEAR,
  S_SWITCH,
  S_MENU_TO_MENU,
  S_MENU_TO_PIC,
  S_PIC_TO_MENU
};

// Version string
String firmwareVersion = "";

// Target data structure
typedef struct {
  int8_t angle;      // Angle (actual = value - 0x80)
  uint8_t distance;  // Distance in meters
  uint8_t direction; // 01=approaching, 00=leaving
  uint8_t speed;     // Speed in km/h
  uint8_t snr;       // Signal-to-noise ratio
} TargetInfo;

// Menu item structure
typedef struct {
  char* select;
} SELECT_LIST;

// Settings menu items
SELECT_LIST set[] {
  {"-maxRange"},
  {"-minSpeed"},
  {"-delayTime"},
  {"-snrLevel"},
  {"-sendSet"},
  {"Return"}
};

// Calculate settings menu dimensions
uint8_t set_num = sizeof(set)/sizeof(SELECT_LIST);
uint8_t single_setline_length = 63/set_num;
uint8_t total_setline_length = single_setline_length*set_num+1;

// Main menu items
SELECT_LIST list[] {
  {"Radar Display"},
  {"SETTING Editor"},
  {"Info"},
  {"About"}
};

// Calculate main menu dimensions
uint8_t list_num = sizeof(list)/sizeof(SELECT_LIST);
uint8_t single_line_length = 63/list_num;
uint8_t total_line_length = single_line_length*list_num+1;

// Button handling structures
typedef struct {
  bool val;
  bool last_val;
} KEY;

KEY key[4] = {false};

typedef struct {
  uint8_t id;
  bool pressed;
} KEY_MSG;

KEY_MSG key_msg = {0};

// Get button state
bool get_key_val(uint8_t ch) {
  switch (ch) {
    case 0: return digitalRead(BTN0);
    case 1: return digitalRead(BTN1);
    case 2: return digitalRead(BTN2);
    case 3: return digitalRead(BTN3);
    default: break;
  }
}

// Initialize button states
void key_init() {
  for(uint8_t i=0; i<(sizeof(key)/sizeof(KEY)); ++i) {
    key[i].val = key[i].last_val = get_key_val(i);
  }
}

// Scan for button presses
void key_scan() {
  for(uint8_t i=0; i<(sizeof(key)/sizeof(KEY)); ++i) {
    key[i].val = get_key_val(i);
    if(key[i].last_val != key[i].val) {
      key[i].last_val = key[i].val;
      if(key[i].val == LOW) {
        key_msg.id = i;
        key_msg.pressed = true;
      }
    }
  }
}

// Animation movement functions
bool move(int16_t* a, int16_t* a_trg) {
  if (*a < *a_trg) {
    *a += SPEED;
    if (*a > *a_trg) *a = *a_trg;
  }
  else if(*a > *a_trg) {
    *a -= SPEED;
    if (*a < *a_trg) *a = *a_trg;
  }
  else {
    return true;
  }
  return false;
}

// Icon movement
bool move_icon(int16_t* a, int16_t* a_trg) {
  if (*a < *a_trg) {
    *a += ICON_SPEED;
    if (*a > *a_trg) *a = *a_trg;
  }
  else if(*a > *a_trg) {
    *a -= ICON_SPEED;
    if (*a < *a_trg) *a = *a_trg;
  }
  else {
    return true;
  }
  return false;
}

// Width animation
bool move_width(uint8_t* a, uint8_t* a_trg, uint8_t select, uint8_t id) {
  if (*a < *a_trg) {
    uint8_t step = 16/SPEED;
    uint8_t len;
    if(ui_index == M_SELECT) {
      len = abs(u8g2.getStrWidth(list[select].select)-u8g2.getStrWidth(list[id==0?select+1:select-1].select));
    }
    else if(ui_index == M_SET) {
      len = abs(u8g2.getStrWidth(set[select].select)-u8g2.getStrWidth(set[id==0?select+1:select-1].select));
    }
    uint8_t width_speed = ((len%step)==0?(len/step):(len/step+1));
    *a += width_speed;
    if (*a > *a_trg) *a = *a_trg;
  }
  else if(*a > *a_trg) {
    uint8_t step = 16/SPEED;
    uint8_t len;
    if(ui_index == M_SELECT) {
      len = abs(u8g2.getStrWidth(list[select].select)-u8g2.getStrWidth(list[id==0?select+1:select-1].select));
    }
    else if(ui_index == M_SET) {
      len = abs(u8g2.getStrWidth(set[select].select)-u8g2.getStrWidth(set[id==0?select+1:select-1].select));
    }
    uint8_t width_speed = ((len%step)==0?(len/step):(len/step+1));
    *a -= width_speed;
    if (*a < *a_trg) *a = *a_trg;
  }
  else {
    return true;
  }
  return false;
}

// Progress bar animation
bool move_bar(uint8_t* a, uint8_t* a_trg) {
  if (*a < *a_trg) {
    uint8_t step = 16/SPEED;
    uint8_t width_speed = ((single_line_length%step)==0?(single_line_length/step):(single_line_length/step+1));
    *a += width_speed;
    if (*a > *a_trg) *a = *a_trg;
  }
  else if(*a > *a_trg) {
    uint8_t step = 16/SPEED;
    uint8_t width_speed = ((single_line_length%step)==0?(single_line_length/step):(single_line_length/step+1));
    *a -= width_speed;
    if (*a < *a_trg) *a = *a_trg;
  }
  else {
    return true;
  }
  return false;
}

// Screen transition effect
void disappear() {
  switch(disappear_step) {
    case 1:
      for(uint16_t i=0; i<buf_len; ++i) {
        if(i%2==0) buf_ptr[i] = buf_ptr[i] & 0x55;
      }
      break;
    case 2:
      for(uint16_t i=0; i<buf_len; ++i) {
        if(i%2!=0) buf_ptr[i] = buf_ptr[i] & 0xAA;
      }
      break;
    case 3:
      for(uint16_t i=0; i<buf_len; ++i) {
        if(i%2==0) buf_ptr[i] = buf_ptr[i] & 0x00;
      }
      break;
    case 4:
      for(uint16_t i=0; i<buf_len; ++i) {
        if(i%2!=0) buf_ptr[i] = buf_ptr[i] & 0x00;
      }
      break;
    default:
      ui_state = S_NONE;
      disappear_step = 0;
      break;
  }
  disappear_step++;
}

/************************** Radar Functions **************************/

/**
 * Parse radar data and extract target information
 * @param targets Pointer to target info array
 * @param targetCount Number of targets detected
 * @return true if parsing successful, false otherwise
 */
bool parseRadarData(TargetInfo* targets, uint8_t* targetCount) {
  while (Serial2.available() >= 1) {
    if (Serial2.peek() == 0xF4) {
      if (Serial2.available() >= 10) { // Header(4) + Length(2) + Footer(4)
        // Read header
        uint8_t header[4];
        Serial2.readBytes(header, 4);

        // Verify header
        if (header[0] == 0xF4 && header[1] == 0xF3 && 
            header[2] == 0xF2 && header[3] == 0xF1) {

          // Get data length
          uint8_t lengthBytes[2];
          Serial2.readBytes(lengthBytes, 2);
          uint16_t dataLength = lengthBytes[0] + (lengthBytes[1] << 8);

          // Check valid length
          if (dataLength >= 0 && dataLength <= 255) {
            if (Serial2.available() >= dataLength + 4) {
              uint8_t* dataBuffer = nullptr;
              if (dataLength > 0) {
                dataBuffer = new uint8_t[dataLength];
                Serial2.readBytes(dataBuffer, dataLength);
              }

              // Read footer
              uint8_t footer[4];
              Serial2.readBytes(footer, 4);

              // Verify footer
              if (footer[0] == 0xF8 && footer[1] == 0xF7 && 
                  footer[2] == 0xF6 && footer[3] == 0xF5) {
                if (dataLength > 0) {
                  *targetCount = dataBuffer[0];
                  uint8_t alertInfo = dataBuffer[1];

                  // Limit target count
                  *targetCount = min(*targetCount, (uint8_t)10);

                  // Parse target info
                  for (uint8_t i = 0; i < *targetCount; i++) {
                    if ((2 + i * 5 + 5) <= dataLength) {
                      uint8_t offset = 2 + i * 5; // 5 bytes per target
                      targets[i].angle = dataBuffer[offset] - 0x80;
                      targets[i].distance = dataBuffer[offset + 1];
                      targets[i].direction = dataBuffer[offset + 2];
                      targets[i].speed = dataBuffer[offset + 3];
                      targets[i].snr = dataBuffer[offset + 4];
                    } else {
                      *targetCount = i;
                      break;
                    }
                  }

                  delete[] dataBuffer;
                  return true;
                } else {
                  *targetCount = 0;
                  delete[] dataBuffer;
                  return true;
                }
              }
              delete[] dataBuffer;
              return false;
            }
            break; // Wait for more data
          }
        }
      } else {
        break; // Wait for complete frame
      }
    }
    Serial2.read(); // Discard invalid byte
  }
  return false;
}

/**
 * Get firmware version string
 * @return Version string in format "Vx.yy.zzzzzzzz"
 */
String getFirmwareVersion() {
  String version = "";
  unsigned long startTime = millis();
  
  // Wait for data with timeout
  while (Serial2.available() < 22) {
    if (millis() - startTime > 2000) {
      return "Unknown";
    }
  }

  uint8_t response[22];
  Serial2.readBytes(response, 22);

  // Parse version components
  int majorVersion = response[7];
  int minorVersion = response[12];
  
  String subVersion = "";
  for (int i = 13; i <= 16; i++) {
    if (response[i] < 10) subVersion += "0";
    subVersion += String(response[i]);
  }

  // Format version string
  version = "V" + String(majorVersion) + "." + 
           (minorVersion < 10 ? "0" : "") + String(minorVersion) + "." + 
           subVersion;

  return version;
}

/**
 * Radar configuration and control commands
 */

// Send enable configuration command
void sendEnableCommand() {
  uint8_t command[] = {0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 
                       0x01, 0x00, 0x04, 0x03, 0x02, 0x01};
  Serial2.write(command, sizeof(command));
  Serial.println("Enable configuration command sent");
}

// Read ACK response
void readAck() {
  delay(500); // Wait for device response
  if (Serial2.available()) {
    Serial.print("Radar response: ");
    while (Serial2.available()) {
      uint8_t incomingByte = Serial2.read();
      Serial.print(incomingByte, HEX);
      Serial.print(" ");
    }
    Serial.println();
  } else {
    Serial.println("No response received, check connection and baud rate");
  }
}

// Reset to factory settings
void resetToFactory() {
  uint8_t command[] = {0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xA2, 0x00, 
                       0x04, 0x03, 0x02, 0x01};
  Serial2.write(command, sizeof(command));
  Serial.println("Factory reset command sent");
}

// Read firmware version
void readFirmwareVersion() {
  uint8_t command[] = {0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xA0, 0x00, 
                       0x04, 0x03, 0x02, 0x01};
  Serial2.write(command, sizeof(command));
  Serial.println("Read firmware version command sent");
}

// End configuration mode
void sendEndConfigCommand() {
  uint8_t command[] = {0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xFE, 0x00, 
                       0x04, 0x03, 0x02, 0x01};
  Serial2.write(command, sizeof(command));
  Serial.println("End configuration command sent");
}

// Set target detection parameters
void setTargetDetectionParams(uint8_t maxRange, uint8_t minSpeed, uint8_t delayTime) {
  uint8_t command[] = {0xFD, 0xFC, 0xFB, 0xFA, 0x06, 0x00, 0x02, 0x00,
                       maxRange, 0x01, minSpeed, delayTime, 0x04, 0x03, 0x02, 0x01};
  Serial2.write(command, sizeof(command));
  Serial.println("Target detection parameters set");
}

// Read target detection parameters
void readTargetDetectionParams() {
  uint8_t command[] = {0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0x12, 0x00, 
                       0x04, 0x03, 0x02, 0x01};
  Serial2.write(command, sizeof(command));
  Serial.println("Reading target detection parameters");
}

// Set radar sensitivity
void setSensitivityParams(uint8_t snrLevel) {
  uint8_t command[] = {0xFD, 0xFC, 0xFB, 0xFA, 0x06, 0x00, 0x03, 0x00,
                       0x02, snrLevel, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01};
  Serial2.write(command, sizeof(command));
  Serial.println("Radar sensitivity parameters set");
}

// Read radar sensitivity
void readSensitivityParams() {
  uint8_t command[] = {0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0x13, 0x00, 
                       0x04, 0x03, 0x02, 0x01};
  Serial2.write(command, sizeof(command));
  Serial.println("Reading radar sensitivity parameters");
}


/************************** UI Display Functions **************************/

/**
 * Display info screen with version information
 */
void info_ui_show() {
  // Display header
  u8g2.setCursor(0, 10);
  u8g2.print("Press anykey to enter");
  
  // Hardware version display
  u8g2.setCursor(0, 22);
  u8g2.print("Radar Version:");
  u8g2.setCursor(0, 32);
  u8g2.print(firmwareVersion);

  // Software version display  
  u8g2.setCursor(0, 44);
  u8g2.print("Firmware Version:");
  u8g2.setCursor(0, 54);
  u8g2.print("V 1.0");

  // Update display buffer
  u8g2.sendBuffer();
}

/**
 * Display selection menu interface
 */
void select_ui_show() {
  // Update animations
  move_bar(&line_y, &line_y_trg);
  move(&y, &y_trg);
  move(&box_y, &box_y_trg);
  move_width(&box_width, &box_width_trg, ui_select, key_msg.id);

  // Draw menu frame
  u8g2.drawVLine(126, 0, total_line_length);
  u8g2.drawPixel(125, 0);
  u8g2.drawPixel(127, 0);

  // Draw menu items
  for(uint8_t i = 0; i < list_num; ++i) {    
    u8g2.drawStr(x, 16*i+y+12, list[i].select);
    u8g2.drawPixel(125, single_line_length*(i+1));
    u8g2.drawPixel(127, single_line_length*(i+1));
  }

  // Draw selection indicator
  u8g2.drawVLine(125, line_y, single_line_length-1);
  u8g2.drawVLine(127, line_y, single_line_length-1);
  u8g2.setDrawColor(2);
  u8g2.drawRBox(0, box_y, box_width, 16, 1);
  u8g2.setDrawColor(1);
}

/**
 * Display settings interface
 */
void set_ui_show() {
  // Update animations
  move_bar(&set_line_y, &set_line_y_trg);
  move(&set_y, &set_y_trg);
  move(&set_box_y, &set_box_y_trg);
  move_width(&set_box_width, &set_box_width_trg, set_select, key_msg.id);

  // Draw settings frame
  u8g2.drawVLine(126, 0, total_setline_length);
  u8g2.drawPixel(125, 0);
  u8g2.drawPixel(127, 0);

  // Draw setting items
  for(uint8_t i = 0; i < set_num; ++i) {    
    u8g2.drawStr(x, 16*i+set_y+12, set[i].select);
    u8g2.drawPixel(125, single_setline_length*(i+1));
    u8g2.drawPixel(127, single_setline_length*(i+1));
  }

  // Draw selection box
  u8g2.setDrawColor(2);
  u8g2.drawRBox(0, set_box_y, set_box_width, 16, 1);
  u8g2.setDrawColor(1);
  u8g2.drawVLine(125, set_line_y, single_setline_length-1);
  u8g2.drawVLine(127, set_line_y, single_setline_length-1);
}

/**
 * Display settings editor interface
 */
void set_edit_ui_show() {
  // Draw editor frame
  u8g2.drawBox(16, 16, 96, 31);
  u8g2.setDrawColor(2);
  u8g2.drawBox(17, 17, 94, 29);
  u8g2.setDrawColor(1);

  if (set_select == 4) {
    // Show sending progress
    u8g2.setCursor(22, 30);
    u8g2.print("Sending...");
    u8g2.drawFrame(18, 36, 60, 8);
    u8g2.drawBox(20, 38, sendProgress, 4);
  } else {
    // Show parameter editor
    u8g2.drawFrame(18, 36, 60, 8);
    u8g2.drawBox(20, 38, (uint8_t)((Setdata[set_select]-SETTING_MIN[set_select])/
                 (SETTING_MAX[set_select]-SETTING_MIN[set_select])*56), 4);

    u8g2.setCursor(22, 30);
    switch(set_select) {
      case 0: u8g2.print("Range[M]"); break;
      case 1: u8g2.print("Speed[kM/s]"); break;
      case 2: u8g2.print("Time[s]"); break;
      case 3: u8g2.print("Level"); break;
      default: break;
    }

    u8g2.setCursor(81, 44);
    u8g2.print(Setdata[set_select]);
  }
}

// Define blinking parameters for target display
bool blink_state_object = false;
unsigned long last_blink_object = 0;
const int BLINK_INTERVAL_object = 500; // Blink interval in ms

/**
 * Display radar interface with target information
 */
void radar_ui_show(uint8_t targetCount, TargetInfo* targets) {
  u8g2.clearBuffer();
  
  // Draw radar background
  u8g2.drawXBMP(0, 0, 128, 64, radar_background);
  
  // Update blink state
  if (millis() - last_blink_object > BLINK_INTERVAL_object) {
    blink_state_object = !blink_state_object;
    last_blink_object = millis();
  }

  if (targetCount > 0) {
    // Find nearest target
    uint8_t nearestIndex = 0;
    for (uint8_t i = 1; i < targetCount; i++) {
      if (targets[i].distance < targets[nearestIndex].distance) {
        nearestIndex = i;
      }
    }
    
    // Display distance and speed
    u8g2.setCursor(15, 64-8);
    u8g2.print(targets[nearestIndex].distance);
    u8g2.print("m");
    
    u8g2.setCursor(128-30, 64-8);
    u8g2.print(targets[nearestIndex].speed);
    u8g2.print("km/h");
    
    // Calculate and draw target position
    float y_pos = map(targets[nearestIndex].distance, 2, 50, 5, 54);
    if (blink_state_object) {
      u8g2.drawCircle(64, y_pos, 3);
      u8g2.drawPixel(64, y_pos);
    }
  } else {
    // Display zeros when no target
    u8g2.setCursor(15, 64-8);
    u8g2.print("0m");
    u8g2.setCursor(128-33, 64-8);
    u8g2.print("0km/h");
  }

  u8g2.sendBuffer();
}

/**
 * Display about screen with device information
 */
void about_ui_show() {
  u8g2.drawStr(2, 12, "MCU : SPRESENSE");
  u8g2.drawStr(2, 28, "RADAR ：LD-2451");
  u8g2.drawStr(2, 44, "Bty. : 3.7V 2000mAh");
  u8g2.drawStr(2, 60, "MADE BY : Hao.P");
}

/************************** UI Event Processing **************************/

/**
 * Process info screen events
 * Handles transition to menu on key press
 */
void info_proc() {
  if(key_msg.pressed) {
    key_msg.pressed = false;
    ui_state = S_DISAPPEAR;
    ui_index = M_SELECT;
  }
  info_ui_show();
}

/**
 * Process set edit screen events
 */
unsigned long lastUpdateTime_S = 0;
const int updateInterval = 200; // 200ms interval
void set_edit_proc(void) {
    if (set_select == 4) {
        // If sending configuration option is selected
        unsigned long currentTime = millis();
        
        if (!isSending) {
            // Initialize sending process
            isSending = true;
            sendStartTime = currentTime;
            sendProgress = 0;
            lastUpdateTime_S = currentTime;
        } else if (currentTime - lastUpdateTime_S >= updateInterval) {
            // Execute sending process step by step
            lastUpdateTime_S = currentTime;
            
            switch(sendProgress) {
                case 0:
                    sendEnableCommand();
                    sendProgress = 15;
                    break;
                    
                case 15:
                    setTargetDetectionParams(Setdata[0], Setdata[1], Setdata[2]);
                    sendProgress = 30;
                    break;
                    
                case 30:
                    setSensitivityParams(Setdata[3]);
                    sendProgress = 45;
                    break;
                    
                case 45:
                    sendEndConfigCommand();
                    sendProgress = 56;
                    break;
                    
                case 56:
                    // Complete sending
                    isSending = false;
                    // Return to main menu
                    ui_index = M_SELECT;
                    ui_state = S_DISAPPEAR;
                    set_select = 0;
                    set_line_y = set_line_y_trg = 0;
                    set_box_y = set_box_y_trg = 0;
                    set_y = set_y_trg = 0;
                    set_box_width = set_box_width_trg = u8g2.getStrWidth(set[0].select) + x*2;
                    break;
            }
        }
    }

    // Handle key input 
    if (key_msg.pressed) {
        key_msg.pressed = false;
        switch (key_msg.id) {
            case 0:  // Decrease parameter
                if (set_select == 4 || isSending) break; // Prevent modification during sending
                if (Setdata[set_select] > SETTING_MIN[set_select]) 
                    Setdata[set_select] -= 1;
                break;
            
            case 1:  // Increase parameter  
                if (set_select == 4 || isSending) break; // Prevent modification during sending
                if (Setdata[set_select] < SETTING_MAX[set_select]) 
                    Setdata[set_select] += 1;
                break;
            
            case 2:  // Return
                if (!isSending) {  // Only allow return when not sending
                    ui_index = M_SET;
                }
                break;
            
            default:
                break;
        }
    }
    
    set_ui_show();
    for (uint16_t i = 0; i < buf_len; ++i) {
        buf_ptr[i] = buf_ptr[i] & (i%2 == 0 ? 0x55 : 0xAA);
    }
    set_edit_ui_show();
}

/**
 * Process set screen events
 */
void set_proc() {
    set_ui_show();
    if (key_msg.pressed) {  
        key_msg.pressed = false;
        switch (key_msg.id) {
            case 0:
                if (set_select != 0) {
                    set_select -= 1;
                    set_line_y_trg -= single_setline_length;
                    // Check if need to scroll up
                    if (set_select < -(set_y/16)) {
                        set_y_trg += 16; // Scroll up one line
                    } else {
                        set_box_y_trg -= 16;   
                    }
                    break;
                } else {
                    break;
                }
                
            case 1:
                if (set_select != 5) { 
                    set_select += 1;
                    set_line_y_trg += single_setline_length;
                    // Check if need to scroll down
                    if ((set_select+1) > (4-set_y/16)) {
                        set_y_trg -= 16; // Scroll down one line
                    } else {
                        set_box_y_trg += 16;
                    }
                } else {
                    break;
                }
                break;
                
            case 2:
                if (set_select == 5) {
                    ui_index = M_SELECT;
                    ui_state = S_DISAPPEAR;
                    set_select = 0;
                    set_box_y = set_box_y_trg = 0;
                    set_y = set_y_trg = 0;
                    set_box_width = set_box_width_trg = u8g2.getStrWidth(set[set_select].select) + x*2;
                } else {
                    if (set_select == 4) {  // When selecting the last item (send configuration)
                        ui_index = M_SET_EDIT;  // Enter edit mode to send configuration
                    } else {
                        ui_index = M_SET_EDIT;  // Enter normal edit mode for other items
                    }
                }
                break;
                
            default:
                break;
        }
        set_box_width_trg = u8g2.getStrWidth(set[set_select].select) + x*2;
    }
}

/**
 * Process selection menu interface
 */
void select_proc(void) {
    if (!key_msg.pressed) {
        select_ui_show();
        return;
    }

    key_msg.pressed = false;
    switch (key_msg.id) {
        case 0: // Up button
            if (ui_select >= 1) {
                ui_select--;
                line_y_trg -= single_line_length;
                if (ui_select < -(y/16)) {
                    y_trg += 16;
                } else {
                    box_y_trg -= 16;   
                }
            }
            break;

        case 1: // Down button
            if ((ui_select + 2) <= (sizeof(list)/sizeof(SELECT_LIST))) {
                ui_select++;
                line_y_trg += single_line_length;
                if ((ui_select + 1) > (4-y/16)) {
                    y_trg -= 16;
                } else {
                    box_y_trg += 16; 
                }
            }
            break;

        case 2: // Select button
            switch (ui_select) {
                case 0:     // Return to info page
                    ui_state = S_DISAPPEAR;
                    ui_index = M_RADAR_DISPLAY;
                    break;
                case 1:     // Go to settings
                    ui_state = S_DISAPPEAR;
                    ui_index = M_SET;
                    break;
                case 2:     // Go to radar display
                    ui_state = S_DISAPPEAR;
                    ui_index = M_INFO;
                    break;
                case 3:     // Go to about page
                    ui_state = S_DISAPPEAR;
                    ui_index = M_ABOUT;
                    break;
            }
            break;
    }
    
    box_width_trg = u8g2.getStrWidth(list[ui_select].select) + x*2;
    select_ui_show();
}

// Global variables for radar detection
#define MAX_TARGETS 10   // 定义最大目标数量
static unsigned long lastUpdateTime = 0;        // Last update timestamp
static TargetInfo targets[MAX_TARGETS];         // Target information buffer
static uint8_t targetCount = 0;                 // Number of detected targets
static unsigned long lastTargetDetectedTime = 0; // Last target detection timestamp
static bool displayCleared = false;             // Display clear flag


// LED control variables
static bool isBlinking = false;
static uint8_t blinkCount = 0;
static unsigned long blinkStartTime = 0;
static const int BLINK_INTERVAL = 600;          // Blink interval in ms

/**
 * Process radar interface and handle target detection
 */
void radar_proc() {
    unsigned long currentTime = millis();
    
    // Handle LED blinking
    handleLEDBlinking(currentTime);
    
    // Process radar data every 500ms
    if (currentTime - lastUpdateTime >= 500) {
        lastUpdateTime = currentTime;
        processRadarData(currentTime);
    }

    // Handle key events
    handleKeyEvents();
}

/**
 * Handle LED blinking logic
 */
void handleLEDBlinking(unsigned long currentTime) {
    if (!isBlinking) return;
    
    if (currentTime - blinkStartTime >= BLINK_INTERVAL) {
        static bool ledState = HIGH;
        blinkStartTime = currentTime;
        
        digitalWrite(LED_PIN, ledState ? LOW : HIGH);
        ledState = !ledState;
        
        if (ledState == HIGH) {
            blinkCount++;
        }
        
        if (blinkCount >= 3) {  // Stop after 3 complete blinks
            isBlinking = false;
            blinkCount = 0;
            digitalWrite(LED_PIN, LOW);
        }
    }
}

/**
 * Process radar data and update display
 */
void processRadarData(unsigned long currentTime) {
    if (!parseRadarData(targets, &targetCount)) {
        return;
    }
    
    if (targetCount > 0) {
        radar_ui_show(targetCount, targets);
        lastTargetDetectedTime = currentTime;
        displayCleared = false;
    } else if (currentTime - lastTargetDetectedTime >= 2000 && !displayCleared) {
        u8g2.clearBuffer();
        u8g2.drawXBMP(0, 0, 128, 64, radar_background);
        radar_ui_show(0, NULL);
        u8g2.sendBuffer();
        displayCleared = true;
    }
}

/**
 * Handle key press events in radar interface
 */
void handleKeyEvents() {
    if (!key_msg.pressed) return;
    
    key_msg.pressed = false;
    switch (key_msg.id) {
        case 0:
        case 1:
        case 2:
            ui_state = S_DISAPPEAR;
            ui_index = M_SELECT;
            break;
            
        case 3:
            isBlinking = true;
            blinkCount = 0;
            blinkStartTime = millis();
            digitalWrite(LED_PIN, HIGH);
            break;
    }
}

/**
 * Process about page interface
 */
void about_proc() {
    if (key_msg.pressed) {
        key_msg.pressed = false;
        ui_state = S_DISAPPEAR;
        ui_index = M_SELECT;
    }
    about_ui_show();
}

/************************** Main UI Display **************************/

/**
 * Process main UI state machine and handle different UI pages
 */
void ui_proc() {
    switch (ui_state) {
        case S_NONE:
            if (ui_index != M_RADAR_DISPLAY) {
                u8g2.clearBuffer();
            }
            
            switch (ui_index) {
                case M_INFO:
                    info_proc();
                    break;
                case M_SELECT:
                    select_proc();
                    break;
                case M_SET:
                    set_proc();
                    break;
                case M_SET_EDIT:
                    set_edit_proc();
                    break;
                case M_ABOUT:
                    about_proc();
                    break;
                case M_RADAR_DISPLAY:  // Radar display page
                    radar_proc();
                    break;
                default:
                    break;
            }
            break;
            
        case S_DISAPPEAR:
            disappear();
            break;
            
        default:
            break;
    }
    u8g2.sendBuffer();
}

/**
 * Setup function - Initialize hardware and system parameters
 */
void setup() {
    // Initialize serial ports
    Serial.begin(115200);   // Debug serial port
    Serial2.begin(115200);  // UART2 for external device communication

    // Initialize GPIO pins
    pinMode(BTN0, INPUT_PULLUP);
    pinMode(BTN1, INPUT_PULLUP);
    pinMode(BTN2, INPUT_PULLUP);
    pinMode(BTN3, INPUT_PULLUP); 
    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);
    
    // Initialize key handling
    key_init();
    
    // Initialize OLED display
    u8g2.setBusClock(800000);
    u8g2.begin();
    u8g2.setFont(u8g2_font_wqy12_t_chinese1);

    // Display startup animation A
    u8g2.clearBuffer();
    u8g2.drawXBMP(0, 0, bitmapA_width, bitmapA_height, bitmapA_bits);
    u8g2.sendBuffer();

    // Initialize radar module
    Serial.println("Initialization complete, starting test...");
    sendEnableCommand();
    delay(500);
    readAck();
    delay(500);
    readFirmwareVersion();
    
    // Display startup animation B
    u8g2.clearBuffer();
    u8g2.drawXBMP(0, 0, bitmapB_width, bitmapB_height, bitmapB_bits);
    u8g2.sendBuffer();

    // Complete radar module initialization
    delay(500);
    firmwareVersion = getFirmwareVersion();
    readAck();
    sendEndConfigCommand();
    delay(1000);
    readAck();
    Serial.println(firmwareVersion);

    // Initialize display buffer
    buf_ptr = u8g2.getBufferPtr();
    buf_len = 8 * u8g2.getBufferTileHeight() * u8g2.getBufferTileWidth();

    // Initialize UI parameters
    x = 4;
    y = y_trg = 0;
    line_y = line_y_trg = 1;
    set_line_y = set_line_y_trg = 1;
    ui_select = set_select = icon_select = 0;
    icon_x = icon_x_trg = 0;
    app_y = app_y_trg = 0;

    // Calculate initial box widths
    box_width = box_width_trg = u8g2.getStrWidth(list[ui_select].select) + x*2;  // Add 2px padding on each side
    set_box_width = set_box_width_trg = u8g2.getStrWidth(set[set_select].select) + x*2;

    // Set initial UI state
    ui_index = M_INFO;
    ui_state = S_NONE;
}

/**
 * Main loop function
 */
void loop() {
    key_scan();  // Scan for key events
    ui_proc();   // Process UI state machine
}